
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>[译]人脸检测与人脸识别简介 | 11zHexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="From: http://www.shervinemami.co.cc/faceRecognition.html/
Translated by 11
“人脸识别”是一个在计算机视觉和生物特征识别领域十分活跃的话题。这个主题已经被给力地研究了25年，并且最终在安全、机器人学、人机交互、数码摄像机、游戏和娱乐领域得到了广泛应用。
“人脸识别”大致可分为两个阶段：
1.人脸检测 搜索一幅图像，寻找一切人">
<meta property="og:type" content="article">
<meta property="og:title" content="[译]人脸检测与人脸识别简介">
<meta property="og:url" content="http://www.sun11.me/blog/2011/face-recognition-introduction-translation/index.html">
<meta property="og:site_name" content="11zHexo">
<meta property="og:description" content="From: http://www.shervinemami.co.cc/faceRecognition.html/
Translated by 11
“人脸识别”是一个在计算机视觉和生物特征识别领域十分活跃的话题。这个主题已经被给力地研究了25年，并且最终在安全、机器人学、人机交互、数码摄像机、游戏和娱乐领域得到了广泛应用。
“人脸识别”大致可分为两个阶段：
1.人脸检测 搜索一幅图像，寻找一切人">
<meta property="og:image" content="http://11zpic-11zpic.stor.sinaapp.com/original/c4874641c9d4ba540d14aa8b64f4d35d.jpg">
<meta property="og:image" content="http://11zpic-11zpic.stor.sinaapp.com/original/0a71d260e3cc2557c918a5892b9e0a4e.jpg">
<meta property="og:image" content="http://11zpic-11zpic.stor.sinaapp.com/original/2d8eed8219f74225270be7e16f40f52c.jpg">
<meta property="og:image" content="http://11zpic-11zpic.stor.sinaapp.com/original/1380ef44406c3de47f7c1b572d9fe8d8.jpg">
<meta property="og:image" content="http://11zpic-11zpic.stor.sinaapp.com/original/a31dc0014de76bf6194e7523e53cdb9f.jpg">
<meta property="og:image" content="http://11zpic-11zpic.stor.sinaapp.com/original/e0a93b99f0dbaace7d3b2f583bdd8f7e.jpg">
<meta property="og:updated_time" content="2016-02-07T12:47:33.282Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[译]人脸检测与人脸识别简介">
<meta name="twitter:description" content="From: http://www.shervinemami.co.cc/faceRecognition.html/
Translated by 11
“人脸识别”是一个在计算机视觉和生物特征识别领域十分活跃的话题。这个主题已经被给力地研究了25年，并且最终在安全、机器人学、人机交互、数码摄像机、游戏和娱乐领域得到了广泛应用。
“人脸识别”大致可分为两个阶段：
1.人脸检测 搜索一幅图像，寻找一切人">
  
    <link rel="alternative" href="/atom.xml" title="11zHexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  
    <link href="//hexo-sun11.qiniudn.com/css/fonts.css" rel="stylesheet" type="text/css">
  
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-31707826-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->

</head>

<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <nav id="upper-nav" class="inner">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <div class="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        
          <a id="nav-github" class="nav-icon" href="https://github.com/sun11"></a>
        
      </div>
    </nav>
    <div id="header-title">
      
        <h1 id="blog-title-wrap">
          Starsky&#39;s Blog
        </h1>
      
    </div>
    <div id="contenedor">
      <ul class="cube">
        <li class="cara">
         <svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="100" width="100" viewBox="-50 -50 200 200">
          <circle cx="50" cy="50" r="45" stroke-width="5" stroke="black" stroke-opacity="0.5" fill-opacity="0"/>
          <rect x="47.5" y="27.5" width="5" height="25" rx="2.5" ry="2.5" fill="black" fill-opacity="0.5" transform="rotate(330 50 50)"/>
          <rect x="48.5" y="16.5" width="3" height="35" rx="1.5" ry="1.5" fill="black" fill-opacity="0.5"/>
        </svg>
        </li>
        <li class="cara">11z</li>
        <li class="cara">H</li>
        <li class="cara">E</li>
        <li class="cara">X</li>
        <li class="cara">O</li>
      </ul>
    </div>
    <nav id="main-nav">
      
        <a class="main-nav-link" href="/">Home</a>
      
        <a class="main-nav-link" href="/archives">Archives</a>
      
        <a class="main-nav-link" href="/about">About</a>
      
      <a class="main-nav-link st-search-show-outputs">Search</a>
    </nav>
  </div>
</header>

    <div class="outer">
      <section id="main"><article id="post-face-recognition-introduction-translation" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/blog/2011/face-recognition-introduction-translation/" class="article-date">
  <time datetime="2011-09-28T16:00:00.000Z" itemprop="datePublished">Sep 29 2011</time>
</h3>
    
  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      [译]人脸检测与人脸识别简介
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>From: <a href="http://www.shervinemami.co.cc/faceRecognition.html/" target="_blank" rel="external">http://www.shervinemami.co.cc/faceRecognition.html/</a></p>
<p>Translated by 11</p>
<p>“人脸识别”是一个在计算机视觉和生物特征识别领域十分活跃的话题。这个主题已经被给力地研究了25年，并且最终在安全、机器人学、人机交互、数码摄像机、游戏和娱乐领域得到了广泛应用。</p>
<p>“人脸识别”大致可分为两个阶段：</p>
<p>1.人脸检测 搜索一幅图像，寻找一切人脸区域（此处以绿色矩形显示），然后进行图像处理，清理脸部图像以便于更好地识别。</p>
<p>2.人脸识别 把上一阶段检测处理得到的人脸图像与数据<a href="http://11zpic-11zpic.stor.sinaapp.com/original/c4874641c9d4ba540d14aa8b64f4d35d.jpg" target="_blank" rel="external"><img align="right" title="facerecOut" src="http://11zpic-11zpic.stor.sinaapp.com/original/c4874641c9d4ba540d14aa8b64f4d35d.jpg" alt="" width="174" height="197" style="margin: 20px;"></a> 库中的已知人脸进行比对，判定人脸对应的人是谁(此处以红色文本显示)。</p>
<p>2002年后，人脸检测已经可以相当可靠地运作。比如OpenCV的Face Detector,对于一个人直视摄像头得到的较清晰图片，大约有90-95%的准确度。通常来说，当人以侧面对准摄像头或与摄像头成一定角度时，较难检测到人脸，有时需要3D Head Pose Estimation。假如图片亮度不是很好，也较难检测到人脸。脸部的部分区域比另一部分区域明亮，带有阴影，模糊，或者戴眼镜，也会影响检测效果。</p>
<p>然而，人脸识别却比人脸检测不可靠得多，一般只有30-70%的准确度。20世纪90年代以来，人脸识别一直是一个很重要的研究领域，但仍然十分不可靠，并且每一年都有更多的识别技术被创造，如文章底部所列出的（Alternatives to Eigenfaces such as 3D face recognition or recognition from video.）</p>
<p>我将向你展示如何使用“特征脸”（Eigenfaces)，也称为主元分析法（Principal Component Analysis or PCA)。相对于普通的神经网络方法（Neural Networks）和Fisher Faces方法来说，这是一个简单和流行的对图片进行的二维人脸识别的方法。</p>
<p>要学习特征脸方法的理论，你需要阅读Face Recognition With Eigenface from Servo Magazine (April 2007)，可能还需要一些数学算法。</p>
<p>首先我将向你解释，怎样实现特征脸的命令行离线训练（offline training from the command-line），基于Servo Magazine tutorial and source-code (May 2007)。</p>
<p>之后，我将说明如何将此扩展成为从网络摄像头进行实时的在线训练:-)</p>
<p></p><p><span style="color: #ff6600;"><strong>使用OpenCV的Face Detector检测人脸</strong></span></p><p></p>
<p></p><p>如上所述，人脸识别的第一个阶段是人脸检测。OpenCV库使得使用它的Haar Cascade Face Detector(也称为Viola-Jones方法)检测正面人脸变得相当简单。</p><br>OpenCV里的“cvHaarDetectObjects”函数执行人脸检测，但是这个函数直接用没有意义，所以最好用这个包装好的函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Perform face detection on the input image, using the given Haar Cascade.</span></span><br><span class="line"><span class="comment">// Returns a rectangle for the detected region in the given image.</span></span><br><span class="line"><span class="function">CvRect <span class="title">detectFaceInImage</span><span class="params">(IplImage *inputImg, CvHaarClassifierCascade* cascade)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="comment">// Smallest face size.</span></span><br><span class="line">	CvSize minFeatureSize = cvSize(<span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">	<span class="comment">// Only search for 1 face.</span></span><br><span class="line">	<span class="keyword">int</span> flags = CV_HAAR_FIND_BIGGEST_OBJECT | CV_HAAR_DO_ROUGH_SEARCH;</span><br><span class="line">	<span class="comment">// How detailed should the search be.</span></span><br><span class="line">	<span class="keyword">float</span> search_scale_factor = <span class="number">1.1f</span>;</span><br><span class="line">	IplImage *detectImg;</span><br><span class="line">	IplImage *greyImg = <span class="number">0</span>;</span><br><span class="line">	CvMemStorage* storage;</span><br><span class="line">	CvRect rc;</span><br><span class="line">	<span class="keyword">double</span> t;</span><br><span class="line">	CvSeq* rects;</span><br><span class="line">	CvSize size;</span><br><span class="line">	<span class="keyword">int</span> i, ms, nFaces;</span><br><span class="line"></span><br><span class="line">	storage = cvCreateMemStorage(<span class="number">0</span>);</span><br><span class="line">	cvClearMemStorage( storage );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the image is color, use a greyscale copy of the image.</span></span><br><span class="line">	detectImg = (IplImage*)inputImg;</span><br><span class="line">	<span class="keyword">if</span> (inputImg-&amp;gt;nChannels &amp;gt; <span class="number">1</span>) &#123;</span><br><span class="line">		size = cvSize(inputImg-&amp;gt;width, inputImg-&amp;gt;height);</span><br><span class="line">		greyImg = cvCreateImage(size, IPL_DEPTH_8U, <span class="number">1</span> );</span><br><span class="line">		cvCvtColor( inputImg, greyImg, CV_BGR2GRAY );</span><br><span class="line">		detectImg = greyImg;	<span class="comment">// Use the greyscale image.</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Detect all the faces in the greyscale image.</span></span><br><span class="line">	t = (<span class="keyword">double</span>)cvGetTickCount();</span><br><span class="line">	rects = cvHaarDetectObjects( detectImg, cascade, storage,</span><br><span class="line">			search_scale_factor, <span class="number">3</span>, flags, minFeatureSize);</span><br><span class="line">	t = (<span class="keyword">double</span>)cvGetTickCount() - t;</span><br><span class="line">	ms = cvRound( t / ((<span class="keyword">double</span>)cvGetTickFrequency() * <span class="number">1000.0</span>) );</span><br><span class="line">	nFaces = rects-&amp;gt;total;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Face Detection took %d ms and found %d objectsn"</span>, ms, nFaces);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get the first detected face (the biggest).</span></span><br><span class="line">	<span class="keyword">if</span> (nFaces &amp;gt; <span class="number">0</span>)</span><br><span class="line">		rc = *(CvRect*)cvGetSeqElem( rects, <span class="number">0</span> );</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		rc = cvRect(-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>);	<span class="comment">// Couldn't find the face.</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (greyImg)</span><br><span class="line">		cvReleaseImage( &amp;amp;greyImg );</span><br><span class="line">	cvReleaseMemStorage( &amp;amp;storage );</span><br><span class="line">	<span class="comment">//cvReleaseHaarClassifierCascade( &amp;amp;cascade );</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> rc;	<span class="comment">// Return the biggest face found, or (-1,-1,-1,-1).</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a id="more"></a><br>现在如果你想要在一张图片里寻找人脸，只需要简单地调用“detectFaceInImage”函数。你也需要指定OpenCV使用的人脸分类器(Face Classifier)。比如，OpenCV自带了一些用于正面脸的分类器，也有一些用于侧面脸的，还有眼睛检测，鼻检测，嘴检测，全身检测等等。你实际上可以任意把其它的分类检测器用于此函数，甚至创造你自己定制的分类检测器，比如车或人的检测(<a title="here" href="http://note.sonots.com/SciSoftware/haartraining.html" target="_blank" rel="external">阅读此处</a>)，但既然正脸检测是唯一十分可靠的，这将是我们唯一要讨论的。<p></p>
<p>对于正面人脸检测，你应该选取这些OpenCV自带的haar级联分类器(Haar Cascade Classifiers,in the “datahaarcascades” folder)。</p>
<p><ul><br>    <li>“haarcascade_frontalface_default.xml”</li><br>    <li>“haarcascade_frontalface_alt.xml”</li><br>    <li>“haarcascade_frontalface_alt2.xml”</li><br>    <li>“haarcascade_frontalface_alt_tree.xml”</li><br></ul></p>
<p><div>每个haar级联分类器都将给出略微不同的结果，这依赖于你的环境因素，所以你甚至可以用全部分类器，把结果结合在一起（如果你想要做尽可能多地检测）。有一些更多的用于眼睛，头部，嘴巴，鼻子的分类器在<a href="http://gias720.dis.ulpgc.es/Gias/modesto.html" target="_blank" rel="external">Modesto’s page</a>下载。</div></p>
<p><div>你可以在你的程序里这样做来进行人脸检测：</div><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Haar Cascade file, used for Face Detection.</span></span><br><span class="line"><span class="built_in">char</span> *faceCascadeFilename = <span class="string">"haarcascade_frontalface_alt.xml"</span>;</span><br><span class="line"><span class="comment">// Load the HaarCascade classifier for face detection.</span></span><br><span class="line">CvHaarClassifierCascade* faceCascade;</span><br><span class="line">faceCascade = (CvHaarClassifierCascade*)cvLoad(faceCascadeFilename, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>( !faceCascade ) &#123;</span><br><span class="line">	printf(<span class="string">"Couldnt load Face detector '%s'n"</span>, faceCascadeFilename);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Grab the next frame from the camera.</span></span><br><span class="line">IplImage *inputImg = cvQueryFrame(<span class="built_in">camera</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perform face detection on the input image, using the given Haar classifier</span></span><br><span class="line">CvRect faceRect = detectFaceInImage(inputImg, faceCascade);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure a valid face was detected.</span></span><br><span class="line"><span class="keyword">if</span> (faceRect.<span class="variable">width</span> &amp;gt; <span class="number">0</span>) &#123;</span><br><span class="line">	printf(<span class="string">"Detected a face at (%d,%d)!n"</span>, faceRect.x, faceRect.y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.... Use <span class="string">'faceRect'</span> and <span class="string">'inputImg'</span> ....</span><br><span class="line"></span><br><span class="line"><span class="comment">// Free the Face Detector resources when the program is finished</span></span><br><span class="line">cvReleaseHaarClassifierCascade( &amp;amp;cascade );</span><br></pre></td></tr></table></figure></p>
<p></p><p style="text-align: left;"><strong><span style="color: #ff6600;">对脸部图像进行预处理以便于识别</span></strong></p><br>现在你已经检测到一张人脸，你可以使用那张人脸图片进行人脸识别。然而，假如你尝试这样简单地从一张普通图片直接进行人脸识别的话，你将会至少损失10%的准确率！<p></p>
<p>在一个人脸识别系统中，应用多种预处理技术对将要识别的图片进行标准化处理是极其重要的。多数人脸识别算法对光照条件十分敏感，所以假如在暗室训练，在明亮的房间就可能不会被识别出来等等。这个问题可归于“lumination dependent”，并且还有其它很多例子，比如脸部也应当在图片的一个十分固定的位置（比如眼睛位置为相同的像素坐标），固定的大小，旋转角度，头发和装饰，表情（笑，怒等），光照方向（向左或向上等），这就是在进行人脸识别前，使用好的图片预处理过滤器十分重要的原因。你还应该做一些其它事情，比如去除脸部周围的多余像素（如用椭圆遮罩，只显示其内部的人脸区域而不是头发或图片背景，因为他们的变化多于脸部区域）。</p>
<p>为简单起见，我展示给你的人脸识别系统是使用灰度图像的特征脸方法。所以我将向你说明怎样简单地把彩色图像转化为灰度图像，并且之后简单地使用直方图均衡化（<a href="http://en.wikipedia.org/wiki/Histogram_equalization" target="_blank" rel="external">Histogram Equalization</a>）作为一种自动的标准化脸部图像亮度和对比度的方法。为了得到更好的结果，你可以使用彩色人脸识别(color face recognition,ideally with color histogram fitting in HSV or another color space instead of RGB)，或者使用更多的预处理，比如边缘增强(edge enhancement),轮廓检测(contour detection),手势检测(motion detection),等等。这份代码把图片调整成一个标准的大小，但是可能会改变脸的纵横比(aspect ratio)。你可以阅读我这里的教程<a title="http://www.shervinemami.co.cc/imageTransforms.html" href="http://www.shervinemami.co.cc/imageTransforms.html" target="_blank" rel="external">HERE</a>，来了解怎样调整图像大小而不改变它的纵横比。</p>
<p>你可以看到一个预处理阶段的例子：</p>
<p><a href="http://11zpic-11zpic.stor.sinaapp.com/original/0a71d260e3cc2557c918a5892b9e0a4e.jpg" target="_blank" rel="external"><img class="size-full wp-image-116 alignnone" title="facerecProcessing" src="http://11zpic-11zpic.stor.sinaapp.com/original/0a71d260e3cc2557c918a5892b9e0a4e.jpg" alt="" width="343" height="96"></a></p>
<p>这是把一幅RGB格式的图像或灰度图像转变为灰度图像的基本代码。它还把图像调整成了固定的维度，然后应用直方图均衡化来实现固定的亮度和对比度。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Either convert the image to greyscale, or use the existing greyscale image.</span></span><br><span class="line">IplImage *imageGrey;</span><br><span class="line"><span class="keyword">if</span> (imageSrc-<span class="subst">&amp;</span><span class="literal">gt</span>;nChannels == <span class="number">3</span>) &#123;</span><br><span class="line">	imageGrey = cvCreateImage( cvGetSize(imageSrc), IPL_DEPTH_8U, <span class="number">1</span> );</span><br><span class="line">	<span class="comment">// Convert from RGB (actually it is BGR) to Greyscale.</span></span><br><span class="line">	cvCvtCol<span class="subst">or</span>( imageSrc, imageGrey, CV_BGR2GRAY );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// Just use the input image, since it is already Greyscale.</span></span><br><span class="line">	imageGrey = imageSrc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Resize the image to be a consistent size, even if the aspect ratio changes.</span></span><br><span class="line">IplImage *imageProcessed;</span><br><span class="line">imageProcessed = cvCreateImage(cvSize(width, height), IPL_DEPTH_8U, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// Make the image a fixed size.</span></span><br><span class="line"><span class="comment">// CV_INTER_CUBIC or CV_INTER_LINEAR is good for enlarging, and</span></span><br><span class="line"><span class="comment">// CV_INTER_AREA is good for shrinking / decimation, but bad at enlarging.</span></span><br><span class="line">cvResize(imageGrey, imageProcessed, CV_INTER_LINEAR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Give the image a standard brightness and contrast.</span></span><br><span class="line">cvEqualizeHist(imageProcessed, imageProcessed);</span><br><span class="line"></span><br><span class="line"><span class="attribute">...</span><span class="built_in">..  </span>Use <span class="string">'imageProcessed'</span> f<span class="subst">or</span> Face Recognition <span class="attribute">...</span><span class="built_in">.</span><br><span class="line"></span><br><span class="line"></span><span class="keyword">if</span> (imageGrey)</span><br><span class="line">	cvReleaseImage(<span class="subst">&amp;</span>amp;imageGrey);</span><br><span class="line"><span class="keyword">if</span> (imageProcessed)</span><br><span class="line">	cvReleaseImage(<span class="subst">&amp;</span>amp;imageProcessed);</span><br></pre></td></tr></table></figure></p>
<p></p><p style="text-align: left;"><strong><span style="color: #ff6600;">把“特征脸”用于人脸识别</span></strong></p><br>现在你已经有了一张经过预处理后的脸部图片，你可以使用特征脸(PCA)进行人脸识别。OpenCV自带了执行PCA操作的”cvEigenDecomposite()”函数，然而你需要一个图片数据库(训练集)告诉机器怎样识别当中的人。<p></p>
<p>所以你应该收集每个人的一组预处理后的脸部图片用于识别。比如，假如你想要从10人的班级当中识别某个人，你可以为每个人存储20张图片，总共就有200张大小相同(如100×100像素)的经预处理的脸部图片。</p>
<p>特征脸的理论在Servo Magazine的两篇文章(<a title="http://www.cognotics.com/opencv/servo_2007_series/part_4/index.html" href="http://www.cognotics.com/opencv/servo_2007_series/part_4/index.html" target="_blank" rel="external">Face Recognition with Eigenface</a>)中解释了，但我仍会在这里尝试着向你解释。</p>
<p>我们使用“主元分析”把你的200张训练图片转换成一个代表这些训练图片主要区别的“特征脸”集。首先它将会通过获取每个像素的平均值，生成这些图片的“平均人脸图片”。然后特征脸将会与“平均人脸”比较。第一个特征脸是最主要的脸部区别，第二个特征脸是第二重要的脸部区别，等等……直到你有了大约50张代表大多数训练集图片的区别的特征脸。</p>
<p><img class="alignleft size-full" title="facerecAverageFace" src="http://11zpic-11zpic.stor.sinaapp.com/original/2d8eed8219f74225270be7e16f40f52c.jpg" alt=""><img class="alignleft size-full" title="facerecEigenface0" src="http://11zpic-11zpic.stor.sinaapp.com/original/1380ef44406c3de47f7c1b572d9fe8d8.jpg" alt="" width="130" height="150"><img class="alignnone size-full" title="facerecEigenface119" src="http://11zpic-11zpic.stor.sinaapp.com/original/a31dc0014de76bf6194e7523e53cdb9f.jpg" alt="" width="130" height="150"></p>
<p>在上面这些示例图片中你可以看到平均人脸和第一个以及最后一个特征脸。它们是从一个四人的每人30幅图片的训练集中生成的。注意到，平均人脸显示的是一个普通人的平滑脸部结构，排在最前的一些特征脸显示了一些主要的脸部特征，而最后的特征脸（比如Eigenface 119）主要是图像噪声。你可以在下面看到前32张特征脸。</p>
<p><a href="http://11zpic-11zpic.stor.sinaapp.com/original/e0a93b99f0dbaace7d3b2f583bdd8f7e.jpg" target="_blank" rel="external"><img class="alignnone size-full wp-image-120" title="facerecEigenfaces" src="http://11zpic-11zpic.stor.sinaapp.com/original/e0a93b99f0dbaace7d3b2f583bdd8f7e.jpg" alt="" width="532" height="307"></a></p>
<p></p><p style="text-align: left;"><strong><span style="color: #ff6600;">使用主元分析法进行人脸识别</span></strong></p><br>简单地说，特征脸方法(Principal Component Analysis)计算出了训练集中图片的主要区别，并且用这些“区别”的组合来代表每幅训练图片。<p></p>
<p>比如，一张训练图片可能是如下的组成：</p>
<p>(averageFace) + (<span style="color: #0000ff;">13.5</span>% of eigenface0) - (<span style="color: #0000ff;">34.3</span>% of eigenface1) + (<span style="color: #0000ff;">4.7</span>% of eigenface2) + … + (<span style="color: #0000ff;">0.0</span>% of eigenface199).</p>
<p>一旦计算出来，就可以认为这张训练图片是这200个比率(ratio)：</p>
<p>{<span style="color: #0000ff;">13.5</span>, <span style="color: #0000ff;">-34.3</span>, <span style="color: #0000ff;">4.7</span>, …, <span style="color: #0000ff;">0.0</span>}.</p>
<p>用特征脸图片分别乘以这些比率，并加上平均人脸图片 (average face)，从这200个比率还原这张训练图片是完全可以做到的。但是既然很多排在后面的特征脸是图像噪声或者不会对图片有太大作用，这个比率表可以被降低到只剩下最主要的,比如前30个，不会对图像质量有很大影响。所以现在可以用30个特征脸，平均人脸图片，和一个含有30个比率的表，来代表全部的200张训练图片。</p>
<p>有趣的是，这意味着，我们已经找到了一种方法把200张图片压缩成31张图片再加上一点点数据，而不丢失很多的图像质量。但是这个教程是关于人脸识别的，而不是图像压缩的，所以我们将会忽略它:-)</p>
<p>在另一幅图片中识别一个人，可以应用相同的PCA计算，使用相同的200个特征脸来寻找200个代表输入图片的比率。并且仍然可以只保留前30个比率而忽略其余的比率，因为它们是次要的。然后通过搜索这些比率的表，寻找在数据库中已知的20个人，来看谁的前30个比率与输入图片的前30个比率最接近。这就是寻找与输入图片最相似的训练图片的基本方法，总共提供了200张训练图片。</p>
<p></p><p><span style="color: #ff6600;"><strong>离线命令行训练的实现</strong></span></p><br>为了实现离线训练，也就是通过命令行(command-line)使用文件作为输入输出，我使用了与Servo Magazine里<a href="http://www.cognotics.com/opencv/servo_2007_series/part_5/index.html" target="_blank" rel="external">Face Recognition with Eigenface</a>相同的实现，所以你可以先阅读这篇文章，但是我做了一些小的改动。<p></p>
<p>基本上，从训练图片创建一个人脸识别数据库，就是创建一个列出图片文件和每个文件代表的人的文本文件。</p>
<p>比如，你可以把这些输入一个名为”4_images_of_2_people.txt”的文本文件：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> Shervin dataShervinShervin1<span class="class">.bmp</span></span><br><span class="line"><span class="number">1</span> Shervin dataShervinShervin2<span class="class">.bmp</span></span><br><span class="line"><span class="number">1</span> Shervin dataShervinShervin3<span class="class">.bmp</span></span><br><span class="line"><span class="number">1</span> Shervin dataShervinShervin4<span class="class">.bmp</span></span><br><span class="line"><span class="number">2</span> Chandan dataChandanChandan1<span class="class">.bmp</span></span><br><span class="line"><span class="number">2</span> Chandan dataChandanChandan2<span class="class">.bmp</span></span><br><span class="line"><span class="number">2</span> Chandan dataChandanChandan3<span class="class">.bmp</span></span><br><span class="line"><span class="number">2</span> Chandan dataChandanChandan4.bmp</span><br></pre></td></tr></table></figure><br>它告诉这个程序，第一个人的名字叫“Shervin”，而Shervin的四张预处理后的脸部图像在”dataShervin”文件夹，第二个人的名字叫”Chandan”，在”dataChandan”中有她的四张图片。这个程序可以使用”loadFaceImgArray()”函数把这些图片加载到一个图片数组中。注意，为了简单起见，它不允许空格或特殊字符出现在人名中，&lt;?&gt;所以你可能想要实现这一功能，或者把人名中的空格用下划线代替（比如 Shervin_Emami）。&lt;/?&gt;</p>
<p>为了从这些加载好的图片中创建一个数据库，你可以使用OpenCV的”cvCalcEigenObjects()”和”cvEigenDecomposite()”函数，比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Tell PCA to quit when it has enough eigenfaces.</span></span><br><span class="line">CvTermCriteria calcLimit = cvTermCriteria( CV_TERMCRIT_ITER, nEigens, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Compute average image, eigenvectors (eigenfaces) and eigenvalues (ratios).</span></span><br><span class="line">cvCalcEigenObjects(nTrainFaces, (<span class="keyword">void</span>*)faceImgArr, (<span class="keyword">void</span>*)eigenVectArr,</span><br><span class="line">	CV_EIGOBJ_NO_CALLBACK, <span class="number">0</span>, <span class="number">0</span>, &amp;amp;calcLimit,</span><br><span class="line">	pAvgTrainImg, eigenValMat-&amp;gt;data.fl);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Normalize the matrix of eigenvalues.</span></span><br><span class="line">cvNormalize(eigenValMat, eigenValMat, <span class="number">1</span>, <span class="number">0</span>, CV_L1, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Project each training image onto the PCA subspace.</span></span><br><span class="line">CvMat projectedTrainFaceMat = cvCreateMat( nTrainFaces, nEigens, CV_32FC1 );</span><br><span class="line"><span class="keyword">int</span> offset = projectedTrainFaceMat-&amp;gt;step / <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&amp;lt;nTrainFaces; i++) &#123;</span><br><span class="line">	cvEigenDecomposite(faceImgArr[i], nEigens, eigenVectArr, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">		pAvgTrainImg, projectedTrainFaceMat-&amp;gt;data.fl + i*offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现在你有了：</p>
<p><ul><br>    <li>平均人脸图片”pAvgTrainImg”，</li><br>    <li>包含特征脸图片的数组”eigenVectArr[]”（如：假如你使用了nEigens=200 张训练图片，将得到200 个特征脸），</li><br>    <li>特征值矩阵 (即特征脸的比率，eigenface ratios) 每张图片的”projectedTrainFaceMat” 。</li><br></ul></p>
<p><div>现在这些可以被储存成一个文件，也就是人脸识别的数据库。代码中的”storeTrainingData()”函数将会把这些数据储存到”facedata.xml“文件里，它可以随时被重新载入来识别经训练过的人。代码中也有一个”storeEigenfaceImages()”的函数，生成前面提到的图片，平均人脸图片被保存到”out_averageImage.bmp”，特征脸被保存到”out_eigenfaces.bmp”。</div></p>
<p></p><p><span style="color: #ff6600;"><strong>离线命令行识别的实现</strong></span></p><br>在离线训练阶段，系统尝试从一个文本文件中的列表读取若干张图像中的人脸，并进行识别。为了实现它，我仍然使用Servo Magazine的<a href="http://www.cognotics.com/opencv/servo_2007_series/part_5/index.html" target="_blank" rel="external">Face Recognition with Eigenface</a>的实现，在此基础上扩展。<p></p>
<p>用于离线训练的相同格式的文本文件也可用于离线识别。这个文本文件列出了用于测试的图像文件和对应于这张图像的正确的人名。随后这个程序就对每一幅图片进行识别，并且检验文本文件中的真实值（图片对应的正确人名）来确认其是否识别正确，并统计它的准确率。</p>
<p>离线识别的实现几乎与离线训练完全相同：</p>
<ol>
<li><p>读取原来的用于训练的文本文件（现在用于识别），把若干个图片文件（预处理后的脸部图片）和名字载入一个图片数组。这些在代码中用“loadFaceImgArray()”函数执行。</p>
</li>
<li><p>平均人脸，特征脸和特征值（比率）使用函数“loadTrainingData()” 从人脸识别数据库文件（the face recognition database fil）“facedata.xml”载入。</p>
</li>
<li><p>使用OpenCV的函数“cvEigenDecomposite()”，每张输入的图片都被投影到PCA子空间，来观察哪些特征脸的比率最适合于代表这张图片。</p>
</li>
<li><p>现在有了特征值（特征脸图片的比率）代表这张输入图片，程序需要查找原始的训练图片，找出拥有最相似比率的图片。这些用数学的方法在“findNearestNeighbor()”函数中执行，采用的是“欧几里得距离（Euclidean Distance）”，但是它只是基本地检查输入图片与每张训练图片的相似性，找到最相似的一张：一张在欧几里得空间上与输入图片距离最近的图片。就像在 Servo Magazine的文章上提到的那样，如果使用马氏距离（ the Mahalanobis space，需要在代码里定义 USE_MAHALANOBIS_DISTANCE），你可以得到更准确的结果。</p>
</li>
<li><p>在输入图片与最相似图片之间的距离用于确定可信度（confidence）,作为是否识别出某人的指导。1.0的可信度意味着完全相同，0.0或者负的可信度意味着非常不相似。但是需要注意，我在代码中用到的可信度公式只是一个非常基本的可信度测量，不是很可靠，但是我觉得多数人会想要看到一个粗略的可信度值。你可能发现它对你的图片给出错误的值，所以你可以禁用它（比如：把可信度设为恒定的1.0）。</p>
</li>
</ol>
<p>一旦指导哪张训练图片和输入图片最相似，并假定可信度值不是太低（应该至少是0.6或更高），那么它就指出了那个人是谁，换句话说，它识别出了那个人！</p>
<p></p><p><span style="color: #ff6600;"><strong>摄像头实时识别的实现</strong></span></p><br>要让一个摄像头视频流输入取代文件列表是十分简单的。基本上，你只要从摄像头抓取一帧，而不是读取一个文件，并且一直运行下去直到用户退出，而不是等待文件读取到头就行了。OpenCV为此提供了“cvCreateCameraCapture()”函数（或cvCaptureFromCAM()）。<p></p>
<p>从摄像头抓取一帧可以简单地用下面的函数实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Grab the next camera frame. Waits until the next frame is ready, and</span></span><br><span class="line"><span class="comment">// provides direct access to it, so do NOT modify or free the returned image!</span></span><br><span class="line"><span class="comment">// Will automatically initialize the camera on the first frame.</span></span><br><span class="line"><span class="function">IplImage* <span class="title">getCameraFrame</span><span class="params">(CvCapture* &amp;amp;camera)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	IplImage *frame;</span><br><span class="line">	<span class="keyword">int</span> w, h;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// If the camera hasn't been initialized, then open it.</span></span><br><span class="line">	<span class="keyword">if</span> (!camera) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Acessing the camera ...\n"</span>);</span><br><span class="line">		camera = cvCreateCameraCapture( <span class="number">0</span> );</span><br><span class="line">		<span class="keyword">if</span> (!camera) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Couldn't access the camera.\n"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Try to set the camera resolution to 320 x 240.</span></span><br><span class="line">		cvSetCaptureProperty(camera, CV_CAP_PROP_FRAME_WIDTH, <span class="number">320</span>);</span><br><span class="line">		cvSetCaptureProperty(camera, CV_CAP_PROP_FRAME_HEIGHT, <span class="number">240</span>);</span><br><span class="line">		<span class="comment">// Get the first frame, to make sure the camera is initialized.</span></span><br><span class="line">		frame = cvQueryFrame( camera );</span><br><span class="line">		<span class="keyword">if</span> (frame) &#123;</span><br><span class="line">			w = frame-&amp;gt;width;</span><br><span class="line">			h = frame-&amp;gt;height;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"Got the camera at %dx%d resolution.\n"</span>, w, h);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Wait a little, so that the camera can auto-adjust its brightness.</span></span><br><span class="line">		Sleep(<span class="number">1000</span>);	<span class="comment">// (in milliseconds)</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Wait until the next camera frame is ready, then grab it.</span></span><br><span class="line">	frame = cvQueryFrame( camera );</span><br><span class="line">	<span class="keyword">if</span> (!frame) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Couldn't grab a camera frame.\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> frame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这个函数可以这样用：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C<span class="title">vCapture* camera = 0</span>;	<span class="comment">// The camera device.</span></span><br><span class="line"><span class="keyword">while</span> <span class="comment">( cvWaitKey(10)</span> != <span class="number">27</span> ) &#123;	<span class="comment">// Quit on "Escape" key.</span></span><br><span class="line">	IplImage *frame = getCameraFrame<span class="comment">(camera)</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Free the camera.</span></span><br><span class="line">cvReleaseCapture<span class="comment">( &amp;amp;camera )</span>;</span><br></pre></td></tr></table></figure><br>请注意，假如你是为windows操作系统开发，你可以使用 Theo Watson 的 <a href="http://muonics.net/school/spring05/videoInput/" target="_blank" rel="external">videoInput Library v0.1995</a> 达到两倍于这些代码的速度。它使用了DirectShow硬件加速,然而OpenCV使用VFW已经15年不变了！<br>把我已经解释的这些部分放到一起，人脸识别系统运行步骤如下：</p>
<ol>
<li><p>从摄像头抓取一帧图片。</p>
</li>
<li><p>转换彩色图片帧为灰度图片帧。</p>
</li>
<li><p>检测灰度图片帧的人脸。</p>
</li>
<li><p>处理图片以显示人脸区域（使用 cvSetImageROI() 和 cvCopyImage()）。</p>
</li>
<li><p>预处理脸部图片。</p>
</li>
<li><p>识别图片中的人。<br></p><p><span style="color: #ff6600;"><strong>摄像头实时训练的实现</strong></span></p><br>现在你已经有了一个用摄像头实时识别人脸的方法，但是要学习新人脸，你不得不关闭这个程序，把摄像头的图片保存成图片文件，更新图片列表，使用离线命令行训练的方法，然后以实时摄像头识别的模式再次运行这个程序。所以实际上，你完全可以用程序来执行实时的摄像头训练！<p></p>
</li>
</ol>
<p>这里就是用摄像头视频流把一个新的人加入人脸识别数据库而不关闭程序的一个最简单的方法：</p>
<ol>
<li><p>从摄像头收集一些图片（预处理后的脸部图片）,也可以同时执行人脸识别。</p>
</li>
<li><p>用“cvSaveImage()”函数保存这些脸部图片作为图片文件存入磁盘。</p>
</li>
<li><p>加入每张脸部图片的文件名到训练图片列表（用于离线命令行训练的文本文件）的底部。</p>
</li>
<li><p>一旦你准备实时训练，你将从所有图片文件形成的数据库重新训练。这个文本文件列出了新加入的训练图片文件，并且这些图片被电脑存为了图片文件，所以实时训练工作起来跟离线训练一样。</p>
</li>
<li><p>但是在重新训练之前，释放任何正在使用的资源和重新初始化也很必要。应该像你重新启动了这个程序一样。比如，在图片被存储成文件并且加入训练列表的文本文件后，你应该再执行相同的离线训练（包括从训练列表文件载入图片，用PCA方法找出新训练集的特征脸和比率）之前释放特征脸数组。 这个实时训练的方法相当低效，因为假如在训练集中有50个人，而你多加了一个人，它将为51个人重新训练，这是非常不好的，因为训练的时间随着用户或图片数量的增加呈指数级增长。但是假如你只是处理百来张图片，它不需要多少秒就可以完成。</p>
</li>
</ol>
<p>文件下载请转到<a title="http://www.shervinemami.co.cc/faceRecognition.html" href="http://www.shervinemami.co.cc/faceRecognition.html" target="_blank" rel="external">原文</a>。</p>
<p>The article source is <a title="http://www.shervinemami.co.cc/faceRecognition.html" href="http://www.shervinemami.co.cc/faceRecognition.html" target="_blank" rel="external">http://www.shervinemami.co.cc/faceRecognition.html</a></p>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenCV/">OpenCV</a></li></ul>

        <a data-url="http://www.sun11.me/blog/2011/face-recognition-introduction-translation/" data-id="cikcpgpxp0008ochx1yh5cwys" class="article-share-link">Share</a>
        
          <a href="http://www.sun11.me/blog/2011/face-recognition-introduction-translation/#disqus_thread" class="article-comment-link">Comments</a>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2012/tl-wr703n-usb-camera/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          TL-WR703n挂载USB摄像头
        
      </div>
    </a>
  
  
    <a href="/blog/2011/quick-dirty-text-writer/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">一个Quick and Dirty的记事本程序</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>
  </section>

</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2013/rosmin-and-rossum/">Rosmin与Rossum</a>
          </li>
        
          <li>
            <a href="/blog/2013/ros-on-arm--native-compilation-on-rk3066/">ROS on ARM--RK3066上本地编译ROS Groovy</a>
          </li>
        
          <li>
            <a href="/blog/2013/ros-on-arm--picuntu-configuration/">ROS on ARM--Picuntu 安装配置</a>
          </li>
        
          <li>
            <a href="/blog/2013/ros-on-arm--linux-for-rk3066/">ROS on ARM--Linux For RK3066 Mini PC简介</a>
          </li>
        
          <li>
            <a href="/blog/2012/wtfrobot-rosmin/">WTFRobot Rosmin</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Customize/">Customize</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Embedded-Linux/">Embedded Linux</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OCR/">OCR</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenCV/">OpenCV</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenWrt/">OpenWrt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Qt/">Qt</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ROS/">ROS</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Robot/">Robot</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ubuntu/">Ubuntu</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">August 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/02/">February 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">January 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">December 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/07/">July 2012</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/02/">February 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/01/">January 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/09/">September 2011</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/08/">August 2011</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/06/">June 2011</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Starsky Wong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/sun11/hexo-theme-paperbox" target="_blank">Paperbox</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
  <a href="#search" class="mobile-nav-link st-search-show-outputs">Search</a>
</nav>
  <!-- totop start -->
<div id="totop">
	<a title="To Top"></a>
</div>
<!-- totop end -->
<!-- swiftype search start -->

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install','rVtxziL4d6HMnCaovhgK','2.0.0');
</script>

<!-- swiftype search end -->


<script>
  var disqus_shortname = '11zhexo';
  
  var disqus_url = 'http://www.sun11.me/blog/2011/face-recognition-introduction-translation/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>

<script src="//cdn.bootcss.com/lrsjng.jquery-qrcode/0.12.0/jquery.qrcode.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

</div>
</body>
</html>
